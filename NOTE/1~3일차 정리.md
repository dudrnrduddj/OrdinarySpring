## 💥 의존성 주입(DI)
### ✨ 생성자를 이용한 의존성 주입
- constructor-arg의 ref에 입력한 객체가 전달되는데 이 객체는 생성자함수의 매개변수로 들어가게 되도록 설계되었다.   
**✔ 단, 생성자의 매개변수가 여러개이고, 전달하는 객체도 여러개라면 순서가 굉장히 중요하게 되고, 또는 속성으로 index를 설정해줄 수 있다.**

### ✨ 어노테이션 이용한 의존성 주입
스프링은 기본적으로 타입을 기준으로 의존성을 주입하며 필드의 타입과 일치하는 빈이 주입된다.
**✔ 단, 동일한 타입의 빈이 여러 개 있는 경우 @Qualifier 어노테이션을 사용하여 특정 빈을 지정할 수 있다.**

####  📢 어노테이션 의존성 주입 시 주의 사항 📢
기본적으로 스프링은 타입을 기준으로 의존성을 주입한다.     
단, 동일한 타입의 빈이 여러 개 있는 경우 @Qualifier("빈의 클래스 이름") 어노테이션을 사용하여 특정 빈을 지정할 수 있다.   
여기서 동일 타입이란 자체 클래스 타입 뿐 아니라 상위 클래스, 인터페이스의 모든 타입을 얘기한다.   
즉, 동일한 클래스나, 인터페이스로부터 상속받는다면 동일 타입으로 인식하므로 각 의존성 주입을 위해 @Qualifier를 활용하자!! 

# 🎉 Spring 동작 구조와 Dispatcher-Servlet의 개념

## 💥 Dispathcer-Servlet이란?
**✔ HTTP프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)라고 정의 할 수 있다.**   
클라이언트로부터 요청이 오면 Tomcat(톰캣)과 같은 서블릿 컨테이너가 요청을 받는다.   
그리고 이 모든 요청을 **프론트 컨트롤러** 인 디스패처 서블릿이 먼저 받게 된다.   
그러면 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임한다.    
  - Front Controller(프론트 컨트롤러) : 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해주는 컨트롤러로써, MVC 구조에서 함께 사용되는 디자인 패턴이다.
		  
		  
##  💥 Dispathcer-Servlet의 장점
디스패처 서블릿은 해당 어플리케이션으로 들어오는 모든 요청을 핸들링 해주고 공통 작업을 처리하기 때문에 우리는 컨트롤러를 구현해두기만 하면 디스패처 서블릿이 알아서 적합한 컨트롤러로 위임을 해주는 구조가 되었다.
		


## 💥 Dispatcher-Servlet(디스패처 서블릿)의 동작 방식

![화면 캡처 2024-07-20 195125](https://github.com/user-attachments/assets/25bf5a79-da55-41f2-931d-cc22654162e9)

 **✔ 1. 클라이언트의 요청을 디스패처 서블릿이 받음**   
   - 디스패처 서블릿은 가장 먼저 요청을 받는 프론트 컨트롤러이다. 서블릿 컨텍스트(웹 컨텍스트)에서 필터들을 지나 스프링 컨텍스트에서 디스패처 서블릿이 가장 먼저 요청을 받게 된다.

 **✔ 2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음**
   - 디스패처 서블릿은 요청을 처리할 핸들러(컨트롤러)를 찾고 해당 객체의 메소드를 호출한다. 따라서 가장 먼저 어느 컨트롤러가 요청을 처리할 수 있는지를 식별해야 하는데, 해당 역할을 하는 것이 **HandlerMapping**이다.   
	-> @Controller, @RrequestMapping 관련 어노테이션을 사용해 컨트롤러를 작성
	
 **✔ 3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함**
  - 디스패처 서블릿은 컨트롤러로 요청을 직접 위임하는 것이 아니라 HandlerAdapter를 통해 위임한다.
	
 **✔ 4. 핸들러 어댑터가 컨트롤러로 요청을 위임함**
   - 핸들러 어댑터가 컨트롤러로 요청을 위임한 전/후에 공통적인 전/후처리 과정이 필요하다. 대표적으로 요청 시에 @RequestParam, @RequestBody 등을 처리하기 위한	ArgumentResolver들과 응답 시에 ResponseEntity의 Body를 Json으로 직렬화하는 등의 처리를 하는 ReturnValueHandler 등이 핸들러 어댑터에서 처리된다. ArgumentResolver 등을 통해 파라미터가 준비 되면 리플렉션을 이용해 컨트롤러로 요청을 위임한다.       

 **✔ 5. 비즈니스 로직을 처리함**
   - 컨트롤러는 서비스를 호출하고 우리가 작성한 비즈니스 로직들이 진행된다.
	
 **✔ 6. 컨트롤러가 반환값을 반환함**
   - 로직이 처리된 후에는 컨트롤러가 반환값을 반환한다. 응답 페이지를 보여주는 경우라면 String으로 View의 이름을 반환한다.
	
 **✔ 7. 핸들러 어댑터가 반환값을 처리함**
   - HandlerAdapter는 컨트롤러로부터 받은 응답을 응답 처리기인 ReturnValueHandler가 후처리한 후 디스패처 서블릿으로 돌려준다.
   - 만약 컨트롤러가 View 이름을 반환하면 ViewResolver를 통해 View를 반환한다.
	 
 **✔ 8. 서버의 응답을 클라이언트로 반환함**
   - 만약 응답이 화면이라면 View의 이름에 맞는 View를 찾아서 반환해주는 ViewResolver가 적절한 화면을 내려준다.

#### 📢 동작 과정 요약
 dispatcher servlet을 통해 요청 받음 -> 위임할 컨트롤러 찾음 -> 컨트롤러에게 요청보낼 핸들러 어댑터 찾고 핸들러 어댑터가 컨트롤러에게 요청 위임 ->
 컨트롤러에서 서비스 호출 및 비즈니스 로직 진행 -> 컨트롤러가 반환값을 반환, 응답페이지를 반환한다면 String으로 view의 이름을 반환 ->
 핸들러어댑터가 viewResolver를 통해 view를 반환 -> view의 이름에 맞는 view를 찾아 viewResolver가 해당 페이지 출력
